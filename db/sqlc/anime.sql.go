// Code generated by sqlc. DO NOT EDIT.
// source: anime.sql

package db

import (
	"context"

	animepb "github.com/AkashGit21/Otaku_API/pb/github.com/AkashGit21/Otaku_API/proto/anime"
	"github.com/lib/pq"
)

const checkID = `-- name: CheckID :one
SELECT EXISTS(SELECT 1 FROM animes WHERE id=$1) as "exists"
`

func (q *Queries) CheckID(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkID, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createAnime = `-- name: CreateAnime :one
INSERT INTO animes (
  name, 
  type,
  summary,
  num_of_episodes, 
  other_names,
  status, 
  genre,
  released
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, name, type, summary, num_of_episodes, other_names, status, genre, released, created_at
`

func (q *Queries) CreateAnime(ctx context.Context, arg *animepb.Anime) (*animepb.Anime, error) {
	row := q.db.QueryRowContext(ctx, createAnime,
		arg.Name,
		arg.Type,
		arg.Summary,
		arg.NumOfEpisodes,
		pq.Array(arg.OtherNames),
		arg.Status,
		pq.Array(arg.Genre),
		arg.Released,
	)
	var i animepb.Anime
	err := row.Scan(
		&i.Id,
		&i.Name,
		&i.Type,
		&i.Summary,
		&i.NumOfEpisodes,
		pq.Array(&i.OtherNames),
		&i.Status,
		pq.Array(&i.Genre),
		&i.Released,
		&i.CreatedAt,
	)
	return &i, err
}

const deleteAnime = `-- name: DeleteAnime :exec
DELETE FROM animes
WHERE id = $1
`

func (q *Queries) DeleteAnime(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteAnime, id)
	return err
}

const getAnime = `-- name: GetAnime :one
SELECT id, name, type, summary, num_of_episodes, other_names, status, genre, released, created_at FROM animes
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAnime(ctx context.Context, id int64) (*animepb.Anime, error) {
	row := q.db.QueryRowContext(ctx, getAnime, id)
	var i animepb.Anime
	err := row.Scan(
		&i.Id,
		&i.Name,
		&i.Type,
		&i.Summary,
		&i.NumOfEpisodes,
		pq.Array(&i.OtherNames),
		&i.Status,
		pq.Array(&i.Genre),
		&i.Released,
		&i.CreatedAt,
	)
	return &i, err
}

// animes.type, animes.summary, animes.num_of_episodes, animes.other_names, animes.status, animes.genre, animes.released, animes.created_at

const listAnimes = `-- name: ListAnimes :many
SELECT animes.id, animes.name, animes.type, animes.summary, animes.num_of_episodes, animes.other_names, animes.status, animes.genre, animes.released, animes.created_at FROM ( SELECT id, name, type, summary, num_of_episodes, other_names, status, genre, released, created_at FROM animes
WHERE name LIKE ( SELECT CONCAT ('%' , $1::text , '%') ) ) AS "animes"
ORDER BY animes.name ASC
OFFSET ($2::int-1)*10 LIMIT 10
`

type ListAnimesParams struct {
	Column1 string `json:"column1"`
	Column2 int32  `json:"column2"`
	// Column3 string `json:"column3"`
}

func (q *Queries) ListAnimes(ctx context.Context, arg ListAnimesParams) ([]*animepb.Anime, error) {
	rows, err := q.db.QueryContext(ctx, listAnimes, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*animepb.Anime
	for rows.Next() {
		var i animepb.Anime
		if err := rows.Scan(
			&i.Id,
			&i.Name,
			&i.Type,
			&i.Summary,
			&i.NumOfEpisodes,
			pq.Array(&i.OtherNames),
			&i.Status,
			pq.Array(&i.Genre),
			&i.Released,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAnime = `-- name: UpdateAnime :exec
UPDATE animes SET 
  name = $2, 
  type = $3,
  summary = $4,
  num_of_episodes = $5, 
  other_names = $6,
  status = $7, 
  genre = $8,
  released = $9
WHERE id = $1
`

func (q *Queries) UpdateAnime(ctx context.Context, arg *animepb.Anime) error {
	_, err := q.db.ExecContext(ctx, updateAnime,
		arg.Id,
		arg.Name,
		arg.Type,
		arg.Summary,
		arg.NumOfEpisodes,
		pq.Array(arg.OtherNames),
		arg.Status,
		pq.Array(arg.Genre),
		arg.Released,
	)
	return err
}
